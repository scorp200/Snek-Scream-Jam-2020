class Vector3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}clone(){return new Vector3(this.x,this.y,this.z)}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this}subtract(b){this.x-=b.x;this.y-=b.y;this.z-=b.z;return this}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;return this}normalize(){const x=this.x;const y=this.y;const z=this.z;let len=x*x+y*y+z*z;if(len>0){len=1/Math.sqrt(len)}this.x=x*len;this.y=y*len;this.z=z*len;return this}dot(b){return this.x*b.x+this.y*b.y+this.z*b.z}cross(b){const ax=this.x;const ay=this.y;const az=this.z;const bx=b.x;const by=b.y;const bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this}set(x,y,z){this.x=x;this.y=y;this.z=z}values(){return[this.x,this.y,this.z]}}class Matrix4{constructor(matrix){this[0]=new Float32Array(matrix?matrix:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);this.states=[]}save(){this.states.push(this.clone());return this}restore(){return this.copy(this.states.pop())}clone(){return new Matrix4(...this[0])}copy(matrix){this[0].set(matrix[0]);return this}identity(){var m=this[0];m[0]=m[5]=m[10]=m[15]=1;m[1]=m[2]=m[3]=m[4]=m[6]=m[7]=m[8]=m[9]=m[11]=m[12]=m[13]=m[14]=0;return this}scale(x,y,z){scalingMatrix[0]=x;scalingMatrix[5]=y;scalingMatrix[10]=z;return this.multiply(scaling)}translate(x,y,z){translationMatrix[3]=x;translationMatrix[7]=y;translationMatrix[11]=z;return this.multiply(translation)}rotate(a,x,y,z){if(!a||!x&&!y&&!z){return this}var d=Math.sqrt(x*x+y*y+z*z);if(x!==0)x/=d;if(y!==0)y/=d;if(z!==0)z/=d;var c=Math.cos(a);var s=Math.sin(a);var t=1-c;rotationMatrix[0]=x*x*t+c;rotationMatrix[1]=x*y*t-z*s;rotationMatrix[2]=x*z*t+y*s;rotationMatrix[4]=y*x*t+z*s;rotationMatrix[5]=y*y*t+c;rotationMatrix[6]=y*z*t-x*s;rotationMatrix[8]=z*x*t-y*s;rotationMatrix[9]=z*y*t+x*s;rotationMatrix[10]=z*z*t+c;return this.multiply(rotation)}perspective(fov,aspect,near,far){const y=Math.tan(fov*Math.PI/360)*near;const x=y*aspect;this.frustum(-x,x,-y,y,near,far)}frustum(l,r,b,t,n,f){let mat=new Matrix4;var m=mat[0];m[0]=2*n/(r-l);m[1]=0;m[2]=(r+l)/(r-l);m[3]=0;m[4]=0;m[5]=2*n/(t-b);m[6]=(t+b)/(t-b);m[7]=0;m[8]=0;m[9]=0;m[10]=-(f+n)/(f-n);m[11]=-2*f*n/(f-n);m[12]=0;m[13]=0;m[14]=-1;m[15]=0;this.multiply(mat);return this}ortho(l,r,b,t,n,f){const m=this[0];m[0]=2/(r-l);m[1]=0;m[2]=0;m[3]=-(r+l)/(r-l);m[4]=0;m[5]=2/(t-b);m[6]=0;m[7]=-(t+b)/(t-b);m[8]=0;m[9]=0;m[10]=-2/(f-n);m[11]=-(f+n)/(f-n);m[12]=0;m[13]=0;m[14]=0;m[15]=1;return this}lookAt(x,y,z,tx,ty,tz,ux,uy,uz){const mat=new Matrix4;const m=mat[0];var e=new Vector3(x,y,z);var c=new Vector3(tx,ty,tz);var u=new Vector3(ux,uy,uz);var f=e.clone().subtract(c).normalize();var s=u.clone().cross(f).normalize();var t=f.clone().cross(s).normalize();m[0]=s.x;m[1]=s.y;m[2]=s.z;m[3]=-s.dot(e);m[4]=t.x;m[5]=t.y;m[6]=t.z;m[7]=-t.dot(e);m[8]=f.x;m[9]=f.y;m[10]=f.z;m[11]=-f.dot(e);m[12]=0;m[13]=0;m[14]=0;m[15]=1;return this.multiply(mat)}multiply(mat){var a=this[0],b=mat[0],c=window["_ufmat"];c[0]=a[0]*b[0]+a[1]*b[4]+a[2]*b[8]+a[3]*b[12];c[1]=a[0]*b[1]+a[1]*b[5]+a[2]*b[9]+a[3]*b[13];c[2]=a[0]*b[2]+a[1]*b[6]+a[2]*b[10]+a[3]*b[14];c[3]=a[0]*b[3]+a[1]*b[7]+a[2]*b[11]+a[3]*b[15];c[4]=a[4]*b[0]+a[5]*b[4]+a[6]*b[8]+a[7]*b[12];c[5]=a[4]*b[1]+a[5]*b[5]+a[6]*b[9]+a[7]*b[13];c[6]=a[4]*b[2]+a[5]*b[6]+a[6]*b[10]+a[7]*b[14];c[7]=a[4]*b[3]+a[5]*b[7]+a[6]*b[11]+a[7]*b[15];c[8]=a[8]*b[0]+a[9]*b[4]+a[10]*b[8]+a[11]*b[12];c[9]=a[8]*b[1]+a[9]*b[5]+a[10]*b[9]+a[11]*b[13];c[10]=a[8]*b[2]+a[9]*b[6]+a[10]*b[10]+a[11]*b[14];c[11]=a[8]*b[3]+a[9]*b[7]+a[10]*b[11]+a[11]*b[15];c[12]=a[12]*b[0]+a[13]*b[4]+a[14]*b[8]+a[15]*b[12];c[13]=a[12]*b[1]+a[13]*b[5]+a[14]*b[9]+a[15]*b[13];c[14]=a[12]*b[2]+a[13]*b[6]+a[14]*b[10]+a[15]*b[14];c[15]=a[12]*b[3]+a[13]*b[7]+a[14]*b[11]+a[15]*b[15];[window["_ufmat"],this[0]]=[this[0],window["_ufmat"]];return this}setCanvasTransform(ctx){var m=this[0];ctx.setTransform(m[0],m[4],m[1],m[5],m[3],m[7]);return this}transpose(){var result=new Matrix4;var m=this[0],r=result[0];r[0]=m[0];r[1]=m[4];r[2]=m[8];r[3]=m[12];r[4]=m[1];r[5]=m[5];r[6]=m[9];r[7]=m[13];r[8]=m[2];r[9]=m[6];r[10]=m[10];r[11]=m[14];r[12]=m[3];r[13]=m[7];r[14]=m[11];r[15]=m[15];return result}transformPoint(point){var m=this[0];var x=point[0],y=point[1],z=point[2],w=point[3];var c1r1=m[0],c2r1=m[1],c3r1=m[2],c4r1=m[3],c1r2=m[4],c2r2=m[5],c3r2=m[6],c4r2=m[7],c1r3=m[8],c2r3=m[9],c3r3=m[10],c4r3=m[11],c1r4=m[12],c2r4=m[13],c3r4=m[14],c4r4=m[15];return[x*c1r1+y*c1r2+z*c1r3+w*c1r4,x*c2r1+y*c2r2+z*c2r3+w*c2r4,x*c3r1+y*c3r2+z*c3r3+w*c3r4,x*c4r1+y*c4r2+z*c4r3+w*c4r4]}transposeTransformPoint(x,y,z,w){const m=this[0];return[x*m[0]+y*m[1]+z*m[2]+w*m[3],x*m[4]+y*m[5]+z*m[6]+w*m[7],x*m[8]+y*m[9]+z*m[10]+w*m[11],x*m[12]+y*m[13]+z*m[14]+w*m[15]]}}var translation=new Matrix4,rotation=new Matrix4,scaling=new Matrix4,translationMatrix=translation[0],rotationMatrix=rotation[0],scalingMatrix=scaling[0];window["_ufmat"]=(new Matrix4)[0];class Camera{constructor(){this.isCamera=true;this.x=0;this.y=0;this.z=0;this.xTo=0;this.yTo=0;this.zTo=0;this.near=1;this.far=1e3;this.fov=70;this.aspect=1;this.projectionMatrix=new Matrix4;this.resetState=new Matrix4}move(x,y,z){this.x=x;this.y=y;this.z=z;return this}lookAt(x,y,z){this.xTo=x;this.yTo=y;this.zTo=z;return this}update(){this.projectionMatrix.identity();this.projectionMatrix.perspective(this.fov,this.aspect,this.near,this.far);this.projectionMatrix.lookAt(this.x,this.y,this.z,this.xTo,this.yTo,this.zTo,0,0,1)}}class OrthographicCamera extends Camera{constructor(x,y,width,height,near,far){super();this.projectionMatrix.ortho(x,width,y,height,near,far)}}class PerspectiveCamera extends Camera{constructor(aspect,fov,near,far){super();this.aspect=aspect;this.fov=fov;this.near=near;this.far=far;this.projectionMatrix.perspective(fov,aspect,near,far)}}class Grid{constructor(width,height,type){this.width=width;this.height=height;this.type=type||Float32Array;this.size=this.width*this.height;this.data=new this.type(this.size)}set(x,y,value){const index=y*this.width+x;this.data[index]=value}get(x,y){const index=y*this.width+x;return this.data[index]}}function isPowerOf2(value){return(value&value-1)==0}function allowDefault(value,defaultValue){return typeof value!=="undefined"?value:defaultValue}function bytesToFloats(args){const output=[];const length=arguments.length;for(var n=0;n<length;n+=1){output.push((arguments[n]&255)/255)}return output}class Color{constructor(r,g,b,a){this.r=allowDefault(r,255);this.g=allowDefault(g,20);this.b=allowDefault(b,147);this.a=allowDefault(a,255);this.floats=new Float32Array([this.r/255,this.g/255,this.b/255,this.a/255])}}class Shader{constructor(gl,source){this.source=source;this.vertex=this.compile(gl,gl.VERTEX_SHADER,source.vertex);this.fragment=this.compile(gl,gl.FRAGMENT_SHADER,source.fragment);this.compiled=null;const prog=gl.createProgram();this.program=prog;gl.attachShader(prog,this.vertex);gl.attachShader(prog,this.fragment);gl.linkProgram(prog);this.status=gl.getProgramParameter(prog,gl.LINK_STATUS);this.attributes={position:gl.getAttribLocation(prog,"aVertex"),texture:gl.getAttribLocation(prog,"aTextureCoord"),normal:gl.getAttribLocation(prog,"aVertexNormal")};this.uniform={matrix:gl.getUniformLocation(prog,"uMatrix"),color:gl.getUniformLocation(prog,"uColor"),modelViewMatrix:gl.getUniformLocation(prog,"uModelViewMatrix")}}compile(gl,type,source){const shader=gl.createShader(type);gl.shaderSource(shader,source);gl.compileShader(shader);const status=gl.getShaderParameter(shader,gl.COMPILE_STATUS);if(!status){throw new TypeError(`couldn't compile shader:\n${gl.getShaderInfoLog(shader)}`)}return shader}}let renderer=undefined;let gl=undefined;class WebGLRenderer{constructor(opt){opt=opt||{};opt.alpha=allowDefault(opt.alpha,false);opt.antialias=allowDefault(opt.antialias,false);opt.backfaceCulling=allowDefault(opt.backfaceCulling,true);this.msaa=allowDefault(opt.msaa,1);this.imageSmoothing=allowDefault(opt.imageSmoothing,false);opt.premultipliedalpha=allowDefault(opt.premultipliedalpha,false);this.onResize=opt.onResize;this.autoResize=opt.autoResize===true;this.width=opt.width||window.innerWidth;this.height=opt.height||window.innerHeight;this.domElement=document.createElement("canvas");document.body.appendChild(this.domElement);this.domCtx=this.domElement.getContext("2d",opt);this.domCtx.imageSmoothingEnabled=false;this.glCanvas=document.createElement("canvas");this.gl=this.glCanvas.getContext("webgl2",opt);this.gl.enable(this.gl.BLEND);if(opt.backfaceCulling)this.gl.enable(this.gl.CULL_FACE);this.gl.enable(this.gl.DEPTH_TEST);this.setSize(this.width,this.height);this.isWebGLRenderer=true;this.animationFrameRequestId=0;this.fps=-1;this.lastFrameTime=-1;this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;this.shader=null;this.boundTexture=null;this.boundVertexBuffer=null;this.setClearColor(0,0,0,255);this.setViewport(0,0,this.width,this.height);if(!gl){renderer=this;gl=this.gl}}clear(color,depth,stencil){if(color){this.gl.clear(this.gl.COLOR_BUFFER_BIT)}if(depth){this.gl.clear(this.gl.DEPTH_BUFFER_BIT)}if(stencil){this.gl.clear(this.gl.STENCIL_BUFFER_BIT)}}render(scene,camera){const gl=this.gl;this.boundVertexBuffer=null;if(this.autoClear){this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil)}gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);const cm=camera.projectionMatrix.transpose();scene.shaders.forEach(shader=>{if(!shader.compiled){shader.compiled=new Shader(gl,shader)}shader.projectionMatrix=cm;gl.useProgram(shader.compiled.program);gl.uniformMatrix4fv(shader.compiled.uniform.matrix,false,cm[0])});scene.meshes.forEach(m=>{m.draw()});this.domCtx.drawImage(this.glCanvas,0,0,this.width,this.height)}setAnimationLoop(callback){if(this._animationFrameRequestId){cancelAnimationFrame(this._animationFrameRequestId);this._animationFrameRequestId=0}const renderer=this;if(callback!==null){let last=performance.now();(function func(timestamp){renderer.dt=timestamp-last;renderer.fps=1/(renderer.dt/1e3);last=timestamp;if(renderer.autoResize&&(renderer.width!==window.innerWidth||renderer.height!==window.innerHeight)){renderer.setSize(window.innerWidth,window.innerHeight);renderer.width=window.innerWidth;renderer.height=window.innerHeight;if(renderer.onResize){renderer.onResize(renderer.width,renderer.height)}}callback(renderer.dt);renderer._animationFrameRequestId=requestAnimationFrame(func)})()}}setClearColor(r,g,b,a){this.gl.clearColor(...bytesToFloats(r,g,b,a))}setSize(width,height){this.domElement.width=width;this.domElement.height=height;this.domCtx.imageSmoothingEnabled=this.imageSmoothing;this.glCanvas.width=width*this.msaa;this.glCanvas.height=height*this.msaa;this.setViewport(0,0,this.glCanvas.width,this.glCanvas.height)}setViewport(x,y,width,height){this.gl.viewport(x,y,width*this.msaa,height*this.msaa)}}class Geometry{constructor(points,coords,colors,normals,faces){this.isGeometry=true;this.isElements=false;this.points=points||[];this.coords=coords||[];this.colors=colors||[];this.normals=normals||[];this.faces=faces||[];this.vBuffer=null;this.cBuffer=null;this.nBuffer=null;this.elementBuffer=null;this.triangleList={points:[],coords:[],normals:[],vBuffer:null,tBuffer:[],nBuffer:[]};this.lineList={points:[],coords:[],normals:[],vBuffer:null,tBuffer:[],nBuffer:[]}}center(){center(this);center(this.triangleList);center(this.lineList)}clone(){const newGeometry=new Geometry(this.points.slice(0),this.coords.slice(0),this.colors.slice(0),this.normals.slice(0),this.faces.slice(0));newGeometry.isElements=this.isElements;return newGeometry}clear(){this.points.length=0;this.coords.length=0;this.colors.length=0;this.normals.length=0;this.faces.length=0;this.vBuffer=null;this.cBuffer=null;this.elementBuffer=null}directDraw(material,mode){const drawElements=this.isElements;const gl$$1=renderer.gl;let bufferSet,pointsCount;if(mode===gl$$1.LINES){bufferSet=this.lineList}else if(mode===gl$$1.POINTS){bufferSet=this.lineList}else if(drawElements){bufferSet=this;pointsCount=bufferSet.faces.length}else{bufferSet=this.triangleList;pointsCount=bufferSet.points.length/3}if(pointsCount>0){const attributes=material.shader.compiled.attributes;const position=attributes.position;const texture=attributes.texture;const normal=attributes.normal;if(position>=0){let vertex_buffer;if(bufferSet.vBuffer){vertex_buffer=bufferSet.vBuffer}else{vertex_buffer=gl$$1.createBuffer();const data=new Float32Array(bufferSet.points);gl$$1.bindBuffer(gl$$1.ARRAY_BUFFER,vertex_buffer);gl$$1.bufferData(gl$$1.ARRAY_BUFFER,data,gl$$1.STATIC_DRAW);bufferSet.vBuffer=vertex_buffer}gl$$1.bindBuffer(gl$$1.ARRAY_BUFFER,vertex_buffer);gl$$1.enableVertexAttribArray(position);gl$$1.vertexAttribPointer(position,3,gl$$1.FLOAT,false,0,0)}if(texture>=0){let texture_buffer;if(bufferSet.cBuffer){texture_buffer=bufferSet.cBuffer}else{texture_buffer=gl$$1.createBuffer();const data=new Float32Array(bufferSet.coords);gl$$1.bindBuffer(gl$$1.ARRAY_BUFFER,texture_buffer);gl$$1.bufferData(gl$$1.ARRAY_BUFFER,data,gl$$1.STATIC_DRAW);bufferSet.cBuffer=texture_buffer}gl$$1.bindBuffer(gl$$1.ARRAY_BUFFER,texture_buffer);gl$$1.enableVertexAttribArray(texture);gl$$1.vertexAttribPointer(texture,2,gl$$1.FLOAT,false,0,0)}if(normal>=0){let normal_buffer;if(bufferSet.nBuffer){normal_buffer=bufferSet.nBuffer}else{normal_buffer=gl$$1.createBuffer();const data=new Float32Array(bufferSet.normals);gl$$1.bindBuffer(gl$$1.ARRAY_BUFFER,normal_buffer);gl$$1.bufferData(gl$$1.ARRAY_BUFFER,data,gl$$1.STATIC_DRAW);bufferSet.nBuffer=normal_buffer}gl$$1.bindBuffer(gl$$1.ARRAY_BUFFER,normal_buffer);gl$$1.enableVertexAttribArray(normal);gl$$1.vertexAttribPointer(normal,3,gl$$1.FLOAT,false,0,0)}if(drawElements){let elementBuffer;if(bufferSet.elementBuffer){elementBuffer=bufferSet.elementBuffer}else{elementBuffer=gl$$1.createBuffer();const data=new Uint32Array(bufferSet.faces);gl$$1.bindBuffer(gl$$1.ELEMENT_ARRAY_BUFFER,elementBuffer);gl$$1.bufferData(gl$$1.ELEMENT_ARRAY_BUFFER,data,gl$$1.STATIC_DRAW);bufferSet.elementBuffer=elementBuffer}gl$$1.bindBuffer(gl$$1.ELEMENT_ARRAY_BUFFER,elementBuffer)}if(drawElements){gl$$1.drawElements(gl$$1.TRIANGLES,pointsCount,gl$$1.UNSIGNED_INT,0)}else{gl$$1.drawArrays(mode,0,pointsCount)}}}generateLineList(){console.time("generating line list");const points=this.triangleList.points;const coords=this.triangleList.coords;const normals=this.triangleList.normals;const newPoints=[];const newCoords=[];const newNormals=[];const length=points.length/3;const hash={};for(var n=0;n<length;n+=3){let line=points.slice(n*3,n*3+6);let line2=[line.slice(3,6),line.slice(0,3)];let lm=line.join();let lm2=line2.join();if(!(hash[lm]||hash[lm2])){hash[lm]=hash[lm2]=true;newPoints.push(...line);newNormals.push(...normals.slice(n*3,n*3+6));newCoords.push(...coords.slice(n*2,n*2+4))}line=points.slice(n*3+3,n*3+9);line2=[line.slice(3,6),line.slice(0,3)];lm=line.join();lm2=line2.join();if(!(hash[lm]||hash[lm2])){hash[lm]=hash[lm2]=true;newPoints.push(...line);newNormals.push(...normals.slice(n*3+3,n*3+9));newCoords.push(...coords.slice(n*2+2,n*2+6))}line=[...points.slice(n*3+6,n*3+9),...points.slice(n*3,n*3+3)];line2=[line.slice(3,6),line.slice(0,3)];lm=line.join();lm2=line2.join();if(!(hash[lm]||hash[lm2])){hash[lm]=hash[lm2]=true;newPoints.push(...line);newNormals.push(...normals.slice(n*3+6,n*3+6+3));newNormals.push(...normals.slice(n*3,n*3+3));newCoords.push(...coords.slice(n*2+4,n*2+6));newCoords.push(...coords.slice(n*2,n*2+2))}}this.lineList.points=newPoints;this.lineList.normals=newNormals;this.lineList.coords=newCoords;console.timeEnd("generating line list")}generateTriangleList(){console.time("generating triangle list");const faces=this.faces;const points=this.points;const coords=this.coords;const normals=this.normals;const length=faces.length/3;const newPoints=new Float32Array(length*3);const newCoords=new Float32Array(length*2);const newNormals=new Float32Array(length*3);for(let n=0;n<length;n++){const i=(faces[n*3]-1)*3;const iC=(faces[n*3+1]-1)*2||i;const iN=(faces[n*3+2]-1)*3||i;newPoints.set(points.slice(i,i+3),n*3);newCoords.set(coords.slice(iC,iC+2),n*2);newNormals.set(normals.slice(iN,iN+3),n*3)}this.triangleList.points=newPoints;this.triangleList.normals=newNormals;this.triangleList.coords=newCoords;console.timeEnd("generating triangle list")}loadOBJ(filepath,opt={}){fetch(filepath).then(response=>response.text()).then(data=>{console.time("loading OBJ data");data=data.split(/\r?\n|\r/g);const points=this.points;const coords=this.coords;const normals=this.normals;const faces=this.faces;const length=data.length;for(let n=0;n<length;n++){let words=data[n].split(" ").filter(w=>w!=="");let type=words.shift();switch(type){case"g":console.log("group",words);break;case"v":spreadNumber(points,words,3);break;case"vt":spreadNumber(coords,words,2);break;case"vn":spreadNumber(normals,words,3);break;case"f":faces.push(...readFaces(words));break}}if(opt.normalize){this.normalize()}if(opt.scale){this.scale(opt.scale,opt.scale,opt.scale)}if(opt.center){this.center()}if(opt.invertCoords){this.invertCoords()}console.timeEnd("loading OBJ data");this.generateTriangleList()})}invertCoords(){const length=this.coords.length;for(let n=1;n<length;n+=2){this.coords[n]=1-this.coords[n]}return this}shiftCoords(x,y){const length=this.coords.length;for(let n=0;n<length;n+=2){this.coords[n]+=x;this.coords[n+1]+=y}return this}scaleCoords(x,y){const length=this.coords.length;for(let n=0;n<length;n+=2){this.coords[n]*=x;this.coords[n+1]*=y}return this}merge(geometry,x=0,y=0,z=0,sx=1,sy=1,sz=1){const faces=geometry.faces;const fLength=faces.length;const opLength=this.points.length/3;for(let n=0;n<fLength;n++){this.faces.push(faces[n]+opLength)}const points=geometry.points;const pLength=points.length;for(let n=0;n<pLength;n+=3){this.points.push(sx*points[n]+x,sy*points[n+1]+y,sz*points[n+2]+z)}this.coords.push(...geometry.coords);this.normals.push(...geometry.normals);if(geometry.isElements){this.isElements=true}this.nBuffer=null;this.cBuffer=null;this.vBuffer=null;this.elementBuffer=null;return this}mirror(x,y,z){const length=this.points.length/3;for(let n=0;n<length;n++){this.points.push(x+(x-this.points[n*3+0]),y+(y-this.points[n*3+1]),z+(z-this.points[n*3+2]))}}normalize(){let minx=1e4;let miny=1e4;let minz=1e4;let maxx=-1e4;let maxy=-1e4;let maxz=-1e4;const points=this.points;const length=points.length;for(let n=0;n<length;n+=3){minx=Math.min(minx,points[n]);maxx=Math.max(maxx,points[n]);miny=Math.min(miny,points[n+1]);maxy=Math.max(maxy,points[n+1]);minz=Math.min(minz,points[n+2]);maxz=Math.max(maxz,points[n+2])}const width=maxx-minx;const height=maxy-miny;const depth=maxz-minz;const scale=Math.min(1/width,1/height,1/depth);for(let n=0;n<length;n++){points[n]*=scale}}scale(x,y,z){scale(this,x,y,z);scale(this.triangleList,x,y,z);scale(this.lineList,x,y,z);return this}translate(x,y,z){const points=this.points;const length=points.length;for(let n=0;n<length;n+=3){points[n+0]+=x;points[n+1]+=y;points[n+2]+=z}return this}rotate(a,x,y,z){const matrix=new Matrix4;const m2=matrix.rotate(a,x,y,z).transpose();const points=this.points;const normals=this.normals;const length=points.length;for(let n=0;n<length;n+=3){const tPoint=m2.transformPoint([...points.slice(n,n+3),1]);points[n+0]=tPoint[0];points[n+1]=tPoint[1];points[n+2]=tPoint[2];const normal=m2.transformPoint([...normals.slice(n,n+3),1]);normals[n+0]=normal[0];normals[n+1]=normal[1];normals[n+2]=normal[2]}return this}}function scale(geo,x,y,z){const points=geo.points;const length=points.length;for(let n=0;n<length;n+=3){points[n]*=x;points[n+1]*=y;points[n+2]*=z}}function center(geo){let minx=1e6;let miny=1e6;let minz=1e6;let maxx=-1e6;let maxy=-1e6;let maxz=-1e6;const points=geo.points;const length=points.length;for(let n=0;n<length;n+=3){minx=Math.min(minx,points[n]);maxx=Math.max(maxx,points[n]);miny=Math.min(miny,points[n+1]);maxy=Math.max(maxy,points[n+1]);minz=Math.min(minz,points[n+2]);maxz=Math.max(maxz,points[n+2])}let width=maxx-minx;let height=maxy-miny;let depth=maxz-minz;let shiftx=-(minx+width/2);let shifty=-(miny+height/2);let shiftz=-(minz+depth/2);for(let n=0;n<length;n+=3){points[n]+=shiftx;points[n+1]+=shifty;points[n+2]+=shiftz}}function readFaces(words){const newFace=[];let face=[];let first=null;let last=null;let i=0;words.forEach(w=>{if(i++>=3){newFace.push(...face);face=[...first,...last]}const w2=w.split(" ");w2.forEach(k=>{const count=(k.match(/\//g)||[]).length;for(var n=count;n<2;n+=1){k+="/"}last=k.split("/").map(w=>Number(w));face.push(...last)});if(!first)first=last});newFace.push(...face);return newFace}function spreadNumber(arr,words,limit=3){const len=arr.length;for(let n=0;n<limit;n++){arr[len+n]=Number(words[n])}}class Material{constructor(){this.color=null}clone(){}}class Texture{constructor(url,options={}){options.noMipmaps=allowDefault(options.noMipmaps,false);const texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);const level=0;const internalFormat=gl.RGBA;const width=1;const height=1;const border=0;const srcFormat=gl.RGBA;const srcType=gl.UNSIGNED_BYTE;const pixel=new Uint8Array([0,0,255,255]);gl.texImage2D(gl.TEXTURE_2D,level,internalFormat,width,height,border,srcFormat,srcType,pixel);const image=new Image;image.onload=()=>{gl.bindTexture(gl.TEXTURE_2D,texture);gl.texImage2D(gl.TEXTURE_2D,level,internalFormat,srcFormat,srcType,image);if(!options.noMipmaps&&isPowerOf2(image.width)&&isPowerOf2(image.height)){gl.generateMipmap(gl.TEXTURE_2D);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR)}else{gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST)}this.ready=true;this.width=image.width;this.height=image.height;const canvas=document.createElement("canvas");const ctx=canvas.getContext("2d");canvas.width=this.width;canvas.height=this.height;ctx.drawImage(image,0,0);this.imageData=ctx.getImageData(0,0,this.width,this.height);this.pixels=this.imageData.data;renderer.boundTexture=null;if(this.onload){this.onload()}};image.src=url;this.uvs=[0,0,1,1];this.ready=false;this.texture=texture;this.width=width;this.height=height;this.onload=()=>{};this.image=image;this.imageData=null}getPixel(x,y){if(this.imageData){const index=(x*this.height+y)*4;return this.pixels.subarray(index,index+3)}}}class Mesh{constructor(geometry,material){this.isMesh=true;this.geometry=geometry;this.material=material;this.position=new Vector3;this.rotation=new Vector3;this.scale=new Vector3(1,1,1);this.matrix=new Matrix4}clone(){return new Mesh(this.geometry,this.material)}draw(){if(!this.geometry){return}const gl$$1=renderer.gl;const m=this;const texture=m.material.texture.texture;if(texture!==renderer.boundTexture){const uSampler=gl$$1.getUniformLocation(this.material.shader.compiled.program,"uSampler");gl$$1.activeTexture(gl$$1.TEXTURE0);gl$$1.bindTexture(gl$$1.TEXTURE_2D,texture);gl$$1.uniform1i(uSampler,0);renderer.boundTexture=texture}m.matrix.identity();m.matrix.translate(m.position.x,m.position.y,m.position.z);m.matrix.rotate(m.rotation.x,1,0,0);m.matrix.rotate(m.rotation.y,0,1,0);m.matrix.rotate(m.rotation.z,0,0,1);m.matrix.scale(m.scale.x,m.scale.y,m.scale.z);var mm=m.matrix.transpose();gl$$1.uniformMatrix4fv(m.material.shader.compiled.uniform.modelViewMatrix,false,mm[0]);if(m.material.color){gl$$1.uniform4fv(m.material.shader.compiled.uniform.color,m.material.color.floats)}const mode=m.material.wireframe?gl$$1.LINES:m.material.points?gl$$1.POINTS:gl$$1.TRIANGLES;m.geometry.directDraw(this.material,mode)}}class Scene{constructor(){this.meshes=[];this.shaders=[]}add(mesh){this.meshes.push(mesh);if(this.shaders.indexOf(mesh.material.shader)===-1){this.shaders.push(mesh.material.shader)}}remove(mesh){const i=this.meshes.indexOf(mesh);if(i>=0){this.meshes.splice(i,1)}}}class PlaneGeometry extends Geometry{constructor(w=1,h=1,wSegments=1,hSegments=1,options={}){const coords=options.coords||[0,0,1,1];const invertCoords=options.invertCoords||0;const wd=wSegments+1;const hd=hSegments+1;const vs=new Float32Array(wd*hd*3);const ns=new Float32Array(wd*hd*3);const cs=new Float32Array(wd*hd*2);const fs=new Uint32Array(wSegments*hSegments*6);for(let n=0,y=0;y<=hSegments;y++)for(let x=0;x<=wSegments;x++,n++){vs[n*3]=x*w;vs[n*3+1]=y*h;ns[n*3+2]=1;cs[n*2]=coords[0]+x/wSegments*(coords[2]-coords[0]);cs[n*2+1]=invertCoords?1-y/hSegments:y/hSegments;cs[n*2+1]=coords[1]+cs[n*2+1]*(coords[3]-coords[1])}for(let n=0,y=0;y<hSegments;y++)for(let x=0;x<wSegments;x++,n+=6){fs[n]=y*wd+x;fs[n+1]=y*wd+x+1;fs[n+2]=y*wd+x+wd;fs[n+3]=y*wd+x+wd;fs[n+4]=y*wd+x+1;fs[n+5]=y*wd+x+1+wd}super(vs,cs,null,ns,fs);this.width=w;this.height=w;this.widthSegments=wSegments;this.heightSegments=hSegments;this.isElements=true}generateLineList(){console.time("generating line list (PlaneGeometry)");const points=this.points;const coords=this.coords;const normals=this.normals;const newPoints=[];const newCoords=[];const newNormals=[];const length=points.length;const w=this.widthSegments+1;const h=this.heightSegments+1;for(let y=0;y<h;y+=1){let n=y*w*3;let last=points.slice(n,n+3);n+=3;for(let x=1;x<w;x+=1){let now=points.slice(n,n+3);newPoints.push(...last,...now);let now2=points.slice(n+w*3-3,n+w*3);newPoints.push(...last,...now2);last=now;let now3=points.slice(n+w*3-3,n+w*3);newPoints.push(...last,...now3);n+=3}let now2=points.slice(n+w*3-3,n+w*3);newPoints.push(...last,...now2)}this.lineList={points:newPoints,normals:newNormals,coords:newCoords};console.timeEnd("generating line list (PlaneGeometry)")}}const textureShader={};textureShader.name="textureShader";textureShader.vertex=`attribute vec3 aVertex;\nattribute vec2 aTextureCoord;\n\nuniform mat4 uMatrix;\nuniform mat4 uModelViewMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main() {\n\tgl_Position = uMatrix * uModelViewMatrix * vec4(aVertex, 1);\n\tvTextureCoord = aTextureCoord;\n}`;textureShader.fragment=`precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main() {\n\tgl_FragColor = texture2D(uSampler, vTextureCoord);\n\tif (gl_FragColor.a != 1.0) {\n\t\tdiscard;\n\t}\n}`;class TextureMaterial extends Material{constructor(texture){super();this.shader=textureShader;this.texture=texture}}const spriteOptions={invertCoords:true};class SpriteHelper{createSprite(url,w,h,oX=0,oY=0){const geometry=new PlaneGeometry(1,1,1,1,spriteOptions);const texture=new Texture(url);const material=new TextureMaterial(texture);texture.onload=()=>{geometry.scale(w||texture.width,h||texture.height,1);geometry.translate(oX,oY,0);geometry.generateTriangleList()};return new Mesh(geometry,material)}drawSprite(sprite,x=0,y=0,xScale=1,yScale=1,rotation=0){sprite.position.x=x;sprite.position.y=y;sprite.scale.x=xScale;sprite.scale.y=yScale;sprite.rotation.z=rotation;sprite.draw()}}class CircleGeometry extends Geometry{constructor(radius,segments){const points=[];const end=Math.PI*2;const delta=(end-theta)/segments;var theta=0;var x1=radius*Math.cos(theta);var y1=radius*Math.sin(theta);var x2,y2;for(var n=1;n<=segments;n+=1){theta+=delta;x2=radius*Math.cos(theta);y2=radius*Math.sin(theta);points.push(0,0,0,x1,y1,0,x2,y2,0);x1=x2;y1=y2}super(points)}}class BoxGeometry extends Geometry{constructor(w,h,d,widthSegments,heightSegments,depthSegments){super([0,0,0,w,0,0,0,h,0,0,h,0,w,0,0,w,h,0,0,0,d,0,h,d,w,0,d,0,h,d,w,h,d,w,0,d,0,0,0,0,h,0,0,h,d,0,0,0,0,h,d,0,0,d,w,0,0,w,h,d,w,h,0,w,0,0,w,0,d,w,h,d,0,0,0,w,0,d,w,0,0,0,0,0,0,0,d,w,0,d,0,h,0,w,h,0,w,h,d,0,h,0,w,h,d,0,h,d])}}const PI=Math.PI;const TAU=Math.PI*2;const DEG_TO_RAD=1/180*PI;class SphereGeometry extends Geometry{constructor(r,sides,segments){const points=[];const coords=[];const normals=[];const faces=[];const dphi=360/sides;const dtheta=180/segments;for(var segment=0;segment<=segments;++segment){var theta=segment*dtheta;for(var side=0;side<=sides;++side){var phi=side*dphi;var pos=new Vector3(r*Math.sin(theta*DEG_TO_RAD)*Math.sin(phi*DEG_TO_RAD),r*Math.cos(theta*DEG_TO_RAD),r*Math.sin(theta*DEG_TO_RAD)*Math.cos(phi*DEG_TO_RAD));var normal=pos.clone().normalize().values();var texCoord=[phi/360,theta/180];points.push(...pos.values());normals.push(...normal);coords.push(...texCoord);if(segment===segments)continue;if(side===sides)continue;if(segment===0){faces.push(...[segment*(sides+1)+side,(segment+1)*(sides+1)+side,(segment+1)*(sides+1)+side+1])}else if(segment===segments-1){faces.push(...[segment*(sides+1)+side,(segment+1)*(sides+1)+side+1,segment*(sides+1)+side+1])}else{faces.push(...[segment*(sides+1)+side,(segment+1)*(sides+1)+side,(segment+1)*(sides+1)+side+1,segment*(sides+1)+side,(segment+1)*(sides+1)+side+1,segment*(sides+1)+side+1])}}}super(points,coords,null,normals,faces);this.isElements=true;this.rotate(Math.PI/2,1,0,0)}}const defaultShader={};defaultShader.name="defaultShader";defaultShader.vertex=`attribute vec3 aVertex;\n\nuniform mat4 uMatrix;\nuniform vec4 uColor;\nuniform mat4 uModelViewMatrix;\n\nvarying vec4 vColor;\n\nvoid main() {\n\n\tvColor = uColor;\n\tgl_Position = uMatrix * uModelViewMatrix * vec4(aVertex, 1);\n\n}`;defaultShader.fragment=`precision mediump float;\n\nvarying vec4 vColor;\n\nvoid main() {\n\tgl_FragColor = vColor;\n}`;class ColorMaterial extends Material{constructor(color){super();this.color=typeof color==="undefined"?new Color:color;this.shader=defaultShader}}const normalShader={};normalShader.name="normalShader";normalShader.vertex=`attribute vec3 aVertex;\nattribute vec3 aVertexNormal;\n\nuniform mat4 uMatrix;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uNormalMatrix;\n\nvarying vec3 vLighting;\n\nvoid main() {\n\n\tgl_Position = uMatrix * uModelViewMatrix * vec4(aVertex, 1.0);\n\n\t// Lighting.\n\tvec3 ambientLight = vec3(0.3, 0.3, 0.3);\n\tvec3 directionalLightColor = vec3(1.0, 1.0, 1.0);\n    vec3 directionalVector = normalize(vec3(0.75, -0.85, 0.8));\n\n\tvec4 transformedNormal = uModelViewMatrix * vec4(aVertexNormal, 0.0);\n\n\tfloat directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\n    vLighting = ambientLight + (directionalLightColor * directional);\n\n}`;normalShader.fragment=`precision mediump float;\n\nvarying vec3 vLighting;\n\nvoid main() {\n\tvec3 color = vec3(1.0, 1.0, 1.0);\n\tgl_FragColor = vec4(color.rgb * vLighting, 1.0);\n}`;class NormalMaterial extends Material{constructor(){super();this.shader=normalShader}}const spriteShader={name:"defaultShader",vertex:`attribute vec3 aVertex;\n\nuniform mat4 uMatrix;\nuniform vec4 uColor;\nuniform mat4 uModelViewMatrix;\n\nvarying vec4 vColor;\n\nvoid main() {\n\n\tvColor = uColor;\n\tgl_Position = uMatrix * uModelViewMatrix * vec4(aVertex, 1);\n\n}`,fragment:`precision mediump float;\n\nvarying vec4 vColor;\n\nvoid main() {\n\tgl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);//vColor;\n}`};class SpriteMaterial extends Material{constructor(){super();this.shader=spriteShader}}const normalTextureShader={};normalTextureShader.name="normalTextureShader";normalTextureShader.vertex=`attribute vec3 aVertex;\nattribute vec3 aVertexNormal;\nattribute vec2 aTextureCoord;\n\nuniform mat4 uMatrix;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uNormalMatrix;\n\nvarying vec3 vLighting;\nvarying vec2 vTextureCoord;\n\nvoid main() {\n\n\tgl_Position = uMatrix * uModelViewMatrix * vec4(aVertex, 1.0);\n\n\t// Lighting.\n\tvec3 ambientLight = vec3(0.3, 0.3, 0.3);\n\tvec3 directionalLightColor = vec3(1.0, 1.0, 1.0);\n    vec3 directionalVector = normalize(vec3(0.75, -0.85, 0.8));\n\n\tvec4 transformedNormal = uModelViewMatrix * vec4(aVertexNormal, 0.0);\n\n\tfloat directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\n    vLighting = ambientLight + (directionalLightColor * directional);\n\n\tvTextureCoord = aTextureCoord;\n\n}`;normalTextureShader.fragment=`precision mediump float;\n\nvarying vec3 vLighting;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main() {\n\tvec3 color = vec3(1.0, 1.0, 1.0);\n\tgl_FragColor = vec4(texture2D(uSampler, vTextureCoord).rgb * vLighting, 1.0);\n}`;class NormalTextureMaterial extends Material{constructor(texture){super();this.shader=normalTextureShader;this.texture=texture}}class WireframeMaterial extends Material{constructor(color){super();this.color=typeof color==="undefined"?new Color:color;this.wireframe=true;this.shader=defaultShader}}const pointShader={};pointShader.vertex=`attribute vec3 aVertex;\nattribute vec3 aVertexNormal;\nattribute vec2 aTextureCoord;\n\nuniform mat4 uMatrix;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uNormalMatrix;\n\nvarying vec3 vLighting;\nvarying vec2 vTextureCoord;\n\nvoid main() {\n\n\tgl_Position = uMatrix * uModelViewMatrix * vec4(aVertex, 1.0);\n\n\t// Lighting.\n\tvec3 ambientLight = vec3(0.3, 0.3, 0.3);\n\tvec3 directionalLightColor = vec3(1.0, 1.0, 1.0);\n    vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\n\n\tvec4 transformedNormal = uModelViewMatrix * vec4(aVertexNormal, 0.0);\n\n\tfloat directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\n    vLighting = ambientLight + (directionalLightColor * directional);\n\n\tvTextureCoord = aTextureCoord;\n\tgl_PointSize = 4.0;\n\n}`;pointShader.fragment=`precision mediump float;\n\nvarying vec3 vLighting;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main() {\n\tfloat dist = distance( gl_PointCoord, vec2(0.5) );\n\tif (dist > 0.5)\n\t\tdiscard;\n\tvec3 color = vec3(1.0, 1.0, 1.0);\n\tgl_FragColor = vec4(texture2D(uSampler, vTextureCoord+(gl_PointCoord/(2048.0/4.0))).rgb * vLighting, 1.0);\n}`;class PointMaterial extends Material{constructor(texture){super();this.texture=texture;this.points=true;this.shader=pointShader}}const HEIGHTMAP_OPTIONS={noMipmaps:true};class TerrainHelper{constructor(){this.isTerrainHelper=true}generateTerrain(height,diff){const heightmap=new Texture(height,HEIGHTMAP_OPTIONS);const heights=new Grid(1,1,Uint8Array);const diffuse=new Texture(diff);const material=new TextureMaterial(diffuse);const mesh=new Mesh(null,material);heightmap.onload=()=>{const width=heightmap.width;const height=heightmap.height;const heights=new Grid(width,height,Uint8Array);const geometry=new PlaneGeometry(1,1,width-1,height-1);const length=geometry.points.length/3;for(let n=0;n<length;n++){heights.data[n]=geometry.points[n*3+2]=heightmap.pixels[n*4+2]}mesh.geometry=geometry;mesh.heights=heights;if(mesh.onload){mesh.onload()}};mesh.heights=heights;return mesh}}export{Camera,OrthographicCamera,PerspectiveCamera,Grid,Color,Matrix4,Mesh,Scene,WebGLRenderer,Texture,SpriteHelper,Geometry,PlaneGeometry,CircleGeometry,BoxGeometry,SphereGeometry,Material,ColorMaterial,NormalMaterial,SpriteMaterial,TextureMaterial,NormalTextureMaterial,WireframeMaterial,PointMaterial,TerrainHelper};